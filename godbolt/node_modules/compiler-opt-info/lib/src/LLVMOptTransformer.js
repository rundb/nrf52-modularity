"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var YAML = require("yamljs");
var stream_1 = require("stream");
var OptInformation_1 = require("../src/OptInformation");
var R = require("ramda");
var optTypeMatcher = /---\s(.*)\n/;
var docStart = "---";
var docEnd = "...";
var IsDocumentStart = function (x) { return x.substring(0, 3) === docStart; };
var FindDocumentEnd = function (x) {
    var index = x.indexOf(docEnd);
    return { found: index > -1, endpos: index + docEnd.length };
};
var LLVMOptTransformer = (function (_super) {
    __extends(LLVMOptTransformer, _super);
    function LLVMOptTransformer(options) {
        var _this = _super.call(this, R.merge(options || {}, { objectMode: true })) || this;
        _this._buffer = "";
        return _this;
    }
    LLVMOptTransformer.prototype._flush = function (done) {
        this.processBuffer();
        done();
    };
    LLVMOptTransformer.prototype._transform = function (chunk, encoding, done) {
        this._buffer += chunk.toString();
        //buffer until we have a start and and end
        //if at any time i care about improving performance stash the offset
        this.processBuffer();
        done();
    };
    LLVMOptTransformer.prototype.processBuffer = function () {
        while (IsDocumentStart(this._buffer)) {
            var _a = FindDocumentEnd(this._buffer), found = _a.found, endpos = _a.endpos;
            if (found) {
                var _b = R.splitAt(endpos, this._buffer), head = _b[0], tail = _b[1];
                var optTypeMatch = head.match(optTypeMatcher);
                var opt = YAML.parse(head);
                if (!optTypeMatch) {
                    console.warn("missing optimization type");
                }
                else {
                    opt.optType = optTypeMatch[1].replace("!", "");
                }
                opt.displayString = OptInformation_1.DisplayOptInfo(opt);
                this.push(opt);
                this._buffer = tail.replace(/^\n/, '');
            }
            else {
                break;
            }
        }
    };
    return LLVMOptTransformer;
}(stream_1.Transform));
exports.LLVMOptTransformer = LLVMOptTransformer;
//# sourceMappingURL=LLVMOptTransformer.js.map